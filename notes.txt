maps preserving the unit disk:
https://math.stackexchange.com/questions/34071/m%C3%B6bius-transforms-that-preserve-the-unit-disk
indra's pearls 87-89

inversion through any circle closed form (non-conjugated form)
indra's pearls 55

old approach to reflection order (could not get working):
idea: generate one loop at a time using reflections in a ring
		like reflect, then reflect the result around the image of the side opposite to the side you reflected by
		(must have a way to identify the two distinct reflection edges (there are always exactly 2!))

		generate the next layer by a reflection through any one of the polygons in that layer
		(must have a way to figure out an edge that is outer)

		I think inner edges, reflection edges, and outer edges can be distinguished as follows:
		let k = # of vertices of the edge that are equal to vertices in a polygon in the previous layer (So k is in 0,1,2)
		if k=0: the edge is an outer edge
		if k=1: the edge is a reflection edge (edge that you can use to seed the successive reflections for a new layer)
		if k=2: the edge is an inner edge (outer edge of previous layer)

		this successive reflection must be performed one less time than there are polygons in that layer
		(the remaining polygon is generated by a reflection from the previous layer)
		
		| layer | #pollies |
		| ---   | ---      |
		| 1     | 1        | (initial polygon)
		| 2     | p+p(q-3) | (p direct reflections from previous layer, q-2 other polygons between them)

		layer 3+ gets really complicated but a closed form is probably attainable with enough thought.
		the alternative is to continue until some empirical check says to stop:
			1. reflect
			2. compute barycenter
			3. compute distance to that layer's initial polygon's barycenter
			4. halt if the distance is under some threshold, continue to next layer
		incidentally this approach also provides a termination condition for the tessellation as a whole.
		by setting the distance threshold to some desired "minimum polygon size" (maybe the distance
		corresponding to 1 or 2 pixels in screen space), the generated tessellation will fill the disk
		to the point where no white space can be seen.


current approach (promising):
Reflect across all edges and rotate about each vertex
1. All vertices except vertices of reflection edge (to next layer) are outer vertices
2. Rotation center is counterclockwise-most vertex of reflection edge
3. On first rotation, other vertex of reflection edge (non-rotation vertex) becomes outer (so everything is outer except rotation vertex itself for each rotation)
4. do not double add vertices
5. all outer vertices except one become rotation centers for the next layer (not true)
6. sort vertices counterclockwise after generation of a full layer so adjacent vertices form an edge (or simply add them in order, which will also help with 4)

approach for mapping pictures to hyperbolic polygons
1. 3-checker square with (i+j)%3==0,1,2
- Non-shader version
Call the map from the square to the hyperbolic polygon f. To compute f(P):
Send a ray from the origin O to the pixel P. Call X the intersection of the ray with the unit apothem square. Compute p=OP/OX. Call Y the intersection of the ray with the hyperbolic polygon*. Then
f(P)=p*(OY-O)=p*OY=p*Y.
See https://www.desmos.com/calculator/0eityg8lym
- Shader version
For each pixel P in hyperbolic polygon, reverse transform to the square (original image) i.e. f^-1(P) and set P to the color at that point. This ensures all pixels in the image of f are colored (finds a restriction S of [0,1]^2 such that f|_S is surjective. Note: the restriction of [0,1]^2 to the pixels of the image is not surjective in practice)

*Computing Y*
- method 1 (too slow): approximate using Euclidean line segments
- method 2: line-circle intersection for the line (cos(a),sin(a))t and the (floor(a/(2pi/p)))th circle (the center radius can be found with circleCenter).